interface ChartQuery {
  data: any[];
  groupBy: string[];          // dimensions for grouping (x-axis)
  pivotBy?: string;           // field for series (like 'response')
  valueField?: string;        // numeric field (optional)
  aggFunc?: "sum" | "count";  // default: 'count'
  filters?: Record<string, any>;
}

export function getChartData({
  data,
  groupBy,
  pivotBy,
  valueField,
  aggFunc = "count",
  filters = {},
}: ChartQuery) {
  // 1️⃣ Filter data
  let filtered = data;
  if (Object.keys(filters).length > 0) {
    filtered = data.filter((row) =>
      Object.entries(filters).every(([key, value]) =>
        Array.isArray(value) ? value.includes(row[key]) : row[key] === value
      )
    );
  }

  // 2️⃣ Aggregate (count if no valueField)
  const grouped = new Map<string, any>();

  filtered.forEach((row) => {
    const groupKey = groupBy.map((g) => row[g]).join("|");
    const pivotKey = pivotBy ? row[pivotBy] : "_total";
    const mapKey = `${groupKey}|${pivotKey}`;

    if (!grouped.has(mapKey)) {
      const base: any = {};
      groupBy.forEach((g) => (base[g] = row[g]));
      base.seriesKey = pivotKey;
      base.value = 0;
      grouped.set(mapKey, base);
    }

    const entry = grouped.get(mapKey);
    if (aggFunc === "count" || !valueField) {
      entry.value += 1; // count records
    } else if (aggFunc === "sum") {
      entry.value += Number(row[valueField]) || 0;
    }
  });

  const rows = Array.from(grouped.values());

  // 3️⃣ Build hierarchical categories
  const hierarchy: Record<string, any> = {};
  for (const r of rows) {
    let level = hierarchy;
    for (let i = 0; i < groupBy.length; i++) {
      const key = r[groupBy[i]];
      if (!level[key]) level[key] = { _children: {} };
      level = level[key]._children;
    }
  }

  function buildCategories(level: any): any[] {
    return Object.entries(level).map(([name, val]) => {
      const children = val._children;
      return Object.keys(children).length
        ? { name, categories: buildCategories(children) }
        : name;
    });
  }

  const categories = buildCategories(hierarchy);

  // 4️⃣ Flatten unique combinations for category lookup
  const uniqueCombos = Array.from(
    new Map(
      rows.map((r) => [groupBy.map((g) => r[g]).join("|"), groupBy.map((g) => r[g])])
    ).values()
  );

  // 5️⃣ Pivot into series
  const pivotValues = Array.from(new Set(rows.map((r) => r.seriesKey)));
  const series = pivotValues.map((p) => ({
    name: p === "_total" ? "Total" : p,
    data: uniqueCombos.map((combo) => {
      const match = rows.find(
        (r) =>
          r.seriesKey === p &&
          groupBy.every((g, i) => r[g] === combo[i])
      );
      return match ? match.value : 0;
    }),
  }));

  return { categories, series };
}
