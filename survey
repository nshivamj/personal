interface ChartQuery {
  data: any[];
  groupBy: string[];          // dimensions for grouping (x-axis)
  pivotBy?: string;           // field for series (like 'response')
  valueField?: string;        // numeric field (optional)
  aggFunc?: "sum" | "count";  // default: 'count'
  filters?: Record<string, any>;
}

export function getChartData({
  data,
  groupBy,
  pivotBy,
  valueField,
  aggFunc = "count",
  filters = {},
}: ChartQuery) {
  // 1Ô∏è‚É£ Filter data
  let filtered = data;
  if (Object.keys(filters).length > 0) {
    filtered = data.filter((row) =>
      Object.entries(filters).every(([key, value]) =>
        Array.isArray(value) ? value.includes(row[key]) : row[key] === value
      )
    );
  }

  // 2Ô∏è‚É£ Aggregate (count if no valueField)
  const grouped = new Map<string, any>();

  filtered.forEach((row) => {
    const groupKey = groupBy.map((g) => row[g]).join("|");
    const pivotKey = pivotBy ? row[pivotBy] : "_total";
    const mapKey = `${groupKey}|${pivotKey}`;

    if (!grouped.has(mapKey)) {
      const base: any = {};
      groupBy.forEach((g) => (base[g] = row[g]));
      base.seriesKey = pivotKey;
      base.value = 0;
      grouped.set(mapKey, base);
    }

    const entry = grouped.get(mapKey);
    if (aggFunc === "count" || !valueField) {
      entry.value += 1; // count records
    } else if (aggFunc === "sum") {
      entry.value += Number(row[valueField]) || 0;
    }
  });

  const rows = Array.from(grouped.values());

  // 3Ô∏è‚É£ Build hierarchical categories
  const hierarchy: Record<string, any> = {};
  for (const r of rows) {
    let level = hierarchy;
    for (let i = 0; i < groupBy.length; i++) {
      const key = r[groupBy[i]];
      if (!level[key]) level[key] = { _children: {} };
      level = level[key]._children;
    }
  }

  function buildCategories(level: any): any[] {
    return Object.entries(level).map(([name, val]) => {
      const children = val._children;
      return Object.keys(children).length
        ? { name, categories: buildCategories(children) }
        : name;
    });
  }

  const categories = buildCategories(hierarchy);

  // 4Ô∏è‚É£ Flatten unique combinations for category lookup
  const uniqueCombos = Array.from(
    new Map(
      rows.map((r) => [groupBy.map((g) => r[g]).join("|"), groupBy.map((g) => r[g])])
    ).values()
  );

  // 5Ô∏è‚É£ Pivot into series
  const pivotValues = Array.from(new Set(rows.map((r) => r.seriesKey)));
  const series = pivotValues.map((p) => ({
    name: p === "_total" ? "Total" : p,
    data: uniqueCombos.map((combo) => {
      const match = rows.find(
        (r) =>
          r.seriesKey === p &&
          groupBy.every((g, i) => r[g] === combo[i])
      );
      return match ? match.value : 0;
    }),
  }));

  return { categories, series };
}











üß© Final Simplified Component ‚Äî SurveyChart

Here‚Äôs the single React component that can render all 4 chart styles based on a chartType prop.
You‚Äôll reuse the same getChartData() function we built earlier (auto-counts rows).

import React, { useEffect, useMemo, useState } from "react";
import Highcharts from "highcharts";
import HighchartsReact from "highcharts-react-official";
import { getChartData } from "./getChartData";

interface SurveyChartProps {
  data: any[];
  title?: string;
  groupBy: string[];
  pivotBy?: string;
  filters?: Record<string, any>;
  chartType?: "bar" | "stackedBar" | "groupedColumn" | "stackedColumn";
  height?: number;
}

export const SurveyChart: React.FC<SurveyChartProps> = ({
  data,
  title = "Survey Chart",
  groupBy,
  pivotBy,
  filters = {},
  chartType = "bar",
  height = 400,
}) => {
  const [chartOptions, setChartOptions] = useState<Highcharts.Options>();

  const chartData = useMemo(
    () =>
      getChartData({
        data,
        groupBy,
        pivotBy,
        filters,
      }),
    [data, groupBy, pivotBy, filters]
  );

  useEffect(() => {
    if (!chartData) return;

    const isBar = chartType.includes("bar");
    const isStacked = chartType.includes("stacked");

    const options: Highcharts.Options = {
      chart: {
        type: isBar ? "bar" : "column",
        height,
        backgroundColor: "transparent",
      },
      title: {
        text: title,
        align: "left",
        style: { fontSize: "16px", fontWeight: "bold" },
      },
      xAxis: {
        categories: chartData.categories,
        title: { text: groupBy.join(" ‚Üí ") },
        labels: { style: { fontSize: "11px" } },
      },
      yAxis: {
        min: 0,
        title: { text: "Count" },
        stackLabels: { enabled: isStacked },
      },
      legend: {
        align: "right",
        verticalAlign: "middle",
        layout: "vertical",
        itemStyle: { fontSize: "11px" },
      },
      tooltip: {
        shared: true,
        formatter: function () {
          return `<b>${this.x}</b><br/>${this.points
            ?.map((p: any) => `${p.series.name}: <b>${p.y}</b>`)
            .join("<br/>")}`;
        },
      },
      plotOptions: {
        series: {
          stacking: isStacked ? "normal" : undefined,
          borderWidth: 0,
          dataLabels: {
            enabled: true,
            style: { fontSize: "10px", textOutline: "none" },
          },
        },
      },
      series: chartData.series as Highcharts.SeriesOptionsType[],
    };

    setChartOptions(options);
  }, [chartData, chartType, title, groupBy, height]);

  return (
    <div style={{ width: "100%", height }}>
      {chartOptions ? (
        <HighchartsReact highcharts={Highcharts} options={chartOptions} />
      ) : (
        <div
          style={{
            height,
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            color: "#777",
          }}
        >
          No data available
        </div>
      )}
    </div>
  );
};

‚úÖ Usage Examples
üîπ Stacked Bar
<SurveyChart
  data={surveyData}
  title="Q1 Response Split by Title"
  groupBy={["title"]}
  pivotBy="response"
  filters={{ questionId: "Q1" }}
  chartType="stackedBar"
/>

üîπ Simple Bar (non-stacked)
<SurveyChart
  data={surveyData}
  title="Response Count by Country"
  groupBy={["country"]}
  pivotBy="response"
  chartType="bar"
/>

üîπ Grouped Column
<SurveyChart
  data={surveyData}
  title="Responses by Year"
  groupBy={["year"]}
  pivotBy="response"
  chartType="groupedColumn"
/>

üîπ Stacked Column
<SurveyChart
  data={surveyData}
  title="Question & Year Split"
  groupBy={["questionId", "year"]}
  pivotBy="response"
  chartType="stackedColumn"
/>
