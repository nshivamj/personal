You are an AI assistant analyzing survey feedback across multiple teams and years.

INPUT:
You will receive a JSON object with an array called "feedback".
Each feedback item contains:
- comment_id
- team
- year
- responder_level (optional: Analyst, Associate, VP, MD, PMD)
- question (optional)
- comment_text

Your objectives:
1) Identify GLOBAL THEMES across all feedback.
2) Classify themes as global strengths or global areas of improvement.
3) Detect trends across years (new, increasing, decreasing, stable).
4) Compare each team against the global themes.
5) Identify team-specific UNIQUE themes.
6) Produce TOP 2 STRENGTHS and TOP 2 IMPROVEMENTS per team for UI display.
7) Ensure audit-safe TRACEABILITY using comment_ids and short quotes.
8) Consider SUPPORT STRENGTH and future-proof RESPONDER LEVEL weighting.

Responder level weighting (if responder_level is present):
- Analyst / Associate = weight 1
- VP = weight 2
- MD / PMD = weight 3
If responder_level is missing, use weight 1.
Use weights only to calculate support strength, NOT to change conclusions unpredictably.

IMPORTANT PRINCIPLES:
- A theme supported by a single comment must be marked LOW confidence.
- UNIQUE themes are valuable only if they have enough support OR high weighted support.
- GLOBAL themes must never be lost; they must still appear in per-team comparison.
- Prefer interpretability, consistency, and defensibility over cleverness.
- Output VALID JSON ONLY using the schema below (no extra keys).

--------------------------------------------------

TASKS:

1) GLOBAL THEMES (All teams combined)
- Identify 5‚Äì10 clear, non-overlapping global themes.
- Assign theme_id values: T1, T2, etc.
- For each theme:
  - Determine dominant sentiment: "strength", "improvement", or "mixed".
  - Write a 2‚Äì3 sentence description.
  - Determine trend across years: "new", "increasing", "decreasing", or "stable".
  - Provide year-wise sentiment stats (approximate).
  - Calculate global support statistics:
    ‚Ä¢ total_comments
    ‚Ä¢ distinct_responders (approximate)
    ‚Ä¢ unweighted_support_score
    ‚Ä¢ weighted_support_score
    ‚Ä¢ confidence: "high", "medium", or "low"
  - Provide representative supporting comment_ids and short quotes (‚â§20 words).

2) GLOBAL SUMMARY
- Place each theme into exactly ONE of:
  - global_summary.strengths
  - global_summary.improvements

3) PER-TEAM ANALYSIS (for EACH distinct team)
- For EVERY global theme:
  - Decide team_status: "strength", "improvement", "mixed", or "not_relevant".
  - Add a one-sentence team-specific summary.
  - Compute team-level support_stats (same structure as global).
  - Include team-specific supporting comment_ids and quotes.

4) TEAM-UNIQUE THEMES
- For each team, identify up to 3 themes not covered by global themes.
- For each unique theme:
  - Assign local_theme_id (TU1, TU2, ‚Ä¶).
  - Mark as "strength" or "improvement".
  - Provide short explanation.
  - Provide support_stats and supporting comments.
- If a unique theme is supported by only one comment, mark confidence as LOW.

5) TOP INSIGHTS PER TEAM (UI CRITICAL)
For each team, generate:
- EXACTLY Top 2 Strengths
- EXACTLY Top 2 Improvements (if possible)

Selection rules:
- Consider both global themes and unique themes.
- Prefer higher weighted_support_score and higher confidence.
- Prefer global themes when the team strongly deviates from global baseline.
- Use unique themes ONLY when:
  ‚Ä¢ More than one responder supports them, OR
  ‚Ä¢ Weighted support is high (senior responders), OR
  ‚Ä¢ No strong global theme exists.
- If a low-sample theme is selected, tag it clearly.

For each selected insight:
- Provide a UI-ready summary_statement (clear, neutral, 1‚Äì2 sentences).
- Indicate whether it is global or unique.
- Add reasoning_tags (examples: "globally_relevant", "team_specific", "high_support", "low_sample_size").
- Provide support_stats and supporting comment_ids.

--------------------------------------------------

OUTPUT JSON SCHEMA (STRICT):

{
  "global_summary": {
    "strengths": [
      {
        "theme_id": "T1",
        "theme_name": "Short theme title",
        "description": "2‚Äì3 sentence explanation.",
        "trend": "new | increasing | decreasing | stable",
        "year_stats": [
          {
            "year": 2024,
            "total_comments": 0,
            "positive_pct": 0,
            "negative_pct": 0,
            "mixed_pct": 0
          }
        ],
        "support_stats_global": {
          "total_comments": 0,
          "distinct_responders": 0,
          "unweighted_support_score": 0,
          "weighted_support_score": 0,
          "confidence": "high | medium | low"
        },
        "supporting_comments": {
          "comment_ids": [],
          "sample_quotes": []
        }
      }
    ],
    "improvements": []
  },
  "per_team_summaries": [
    {
      "team_name": "Team Name",
      "themes_vs_global": [
        {
          "theme_id": "T1",
          "theme_name": "Theme name",
          "team_status": "strength | improvement | mixed | not_relevant",
          "short_summary": "1 sentence summary",
          "support_stats_team": {
            "total_comments": 0,
            "distinct_responders": 0,
            "unweighted_support_score": 0,
            "weighted_support_score": 0,
            "confidence": "high | medium | low"
          },
          "supporting_comments": {
            "comment_ids": [],
            "sample_quotes": []
          }
        }
      ],
      "team_unique_themes": [
        {
          "local_theme_id": "TU1",
          "theme_name": "Unique theme name",
          "type": "strength | improvement",
          "short_summary": "Short explanation",
          "support_stats_team": {
            "total_comments": 0,
            "distinct_responders": 0,
            "unweighted_support_score": 0,
            "weighted_support_score": 0,
            "confidence": "high | medium | low"
          },
          "supporting_comments": {
            "comment_ids": [],
            "sample_quotes": []
          }
        }
      ],
      "team_top_insights": {
        "top_strengths": [
          {
            "source": "global_theme | team_unique_theme",
            "theme_id": "T1 or TU1",
            "theme_name": "Theme name",
            "summary_statement": "UI-ready insight statement.",
            "reasoning_tags": [],
            "support_stats": {
              "total_comments": 0,
              "distinct_responders": 0,
              "unweighted_support_score": 0,
              "weighted_support_score": 0,
              "confidence": "high | medium | low"
            },
            "supporting_comments": {
              "comment_ids": [],
              "sample_quotes": []
            }
          }
        ],
        "top_improvements": []
      }
    }
  ],
  "meta": {
    "total_comments": 0,
    "total_teams": 0,
    "years_covered": []
  }
}

















That‚Äôs your ‚Äúmaster‚Äù analysis prompt.

---

## 2Ô∏è‚É£ Prompt for your Copilot / UI agent (React UI)

Use this with GitHub Copilot / Cursor / your UI agent to build the frontend around that JSON.

```text
I have a JSON response from an AI model with this structure (simplified):

- global_summary.themes[]: global themes with:
  - theme_id, theme_name, type, description, trend
  - support_stats (total_comments, weighted_support_score, support_strength, confidence, etc.)
- global_summary.strengths_theme_ids[], improvements_theme_ids[]
- per_team_summaries[]:
  - team_name
  - themes_vs_global[]: one entry per global theme for this team
  - team_unique_themes[]
  - team_top_insights:
    - strengths[]: top 2 items for UI (each maps to either a global or unique theme)
    - improvements[]: top 2 items for UI
- meta: total_comments, years_covered, teams, weighting_assumptions

I want you to build a React (TypeScript) UI that uses this JSON to show insights to audit team users.

Requirements:

1. Data model:
   - Define TypeScript interfaces for the JSON structure (GlobalTheme, SupportStats, TeamSummary, TeamTopInsight, etc.).
   - Assume the JSON is fetched from an API endpoint (e.g., /api/audit-feedback-insights).
   - Create a hook or context to load the JSON once and provide it to components.

2. Layout:
   - Main page layout:
     - Left column: a scrollable list / table of teams (per_team_summaries).
       - Columns: Team name, top 1‚Äì2 strength titles (from team_top_insights.strengths), top 1‚Äì2 improvement titles (from team_top_insights.improvements).
       - Each row clickable to select that team.
     - Right panel: details for the selected team.

3. Team details panel (right):
   - Section A: "Top strengths for this team"
     - Render cards using team_top_insights.strengths:
       - Show display_title as card title.
       - Show ui_statement as body text.
       - Show badges for:
         - Generic vs Unique (based on theme_ref_type).
         - support_stats.support_strength (e.g., "High support", "Medium support", "Single mention").
         - confidence (e.g., 0.85 ‚Üí "High confidence").
   - Section B: "Top areas for improvement"
     - Same pattern using team_top_insights.improvements.
   - Section C: "Theme breakdown vs global"
     - For each themes_vs_global entry:
       - Show theme_name, team_status (with colored pill: green=strength, red=improvement, grey=not_relevant, yellow=mixed).
       - Show a tiny bar/tags with total_comments and a quick indication of sentiment (e.g. positive vs negative counts).
       - Add a "View evidence" button.
   - Section D: "Evidence drawer / modal"
     - When user clicks "View evidence" on any theme/insight:
       - Open a side drawer or modal showing:
         - Selected team and theme_name.
         - Short_summary (for that team & theme).
         - A list of supporting comments:
           - For now, show comment_ids and sample_quotes from supporting_comments.
           - Placeholder UI hook where we can later fetch the full comment text by id.
       - If is_outlier is true on the top insight, show a small warning note like:
         - "Based on limited comments ‚Äì treat as a directional signal, not a strong pattern."

4. Global view:
   - Add a tab or collapsible panel called "Global themes".
   - Show:
     - For each global_summary.theme:
       - theme_name, type, trend, description.
       - A visual indicator of support_strength (e.g., dot with Low / Medium / High).
     - A small summary for "Top global strengths" and "Top global areas for improvement" using strengths_theme_ids and improvements_theme_ids.

5. Reusability:
   - Separate components clearly:
     - TeamList
     - TeamDetailPanel
     - InsightCard
     - ThemeBreakdownTable
     - EvidenceModal
     - GlobalThemesPanel
   - Each component receives typed props.

6. UX expectations:
   - Use a clean, dashboard-like layout.
   - Use simple flexbox or CSS grid (no need for heavy styling framework unless you want to use something like MUI or Chakra UI).
   - Handle loading and error states for the API call.

Deliverables:
- All relevant React components (TypeScript).
- Example usage with a mock JSON object inline so I can see the UI without wiring a real backend yet.
- Comments in code explaining where the real API call would go and where we could later plug in a "fetch full comments by ID" function.













Subject: Concise Summary of Our Taxonomy & Audit Strategy Data Model

Hi ,

Below is a short, high-level summary of our data model across taxonomy, PCAT, and the new audit-strategy scoping.

‚∏ª

1. PCAT (Mongo) ‚Äì Project-Level Scoping
	‚Ä¢	For each project, we store a list of objects containing OU, BP, RC, ToR, Control, Status.
	‚Ä¢	These combinations are created per project when users select items in the UI.
	‚Ä¢	PCAT today does not store a central master list of unique combinations.

‚∏ª

2. Taxonomy Model (Master Data)
	‚Ä¢	Independent tables for OU, BP, RC, ToR, Control.
	‚Ä¢	Relationship mappings form a tree: OU ‚Üí BP ‚Üí RC ‚Üí ToR ‚Üí Control.
	‚Ä¢	This defines the authoritative taxonomy structure (but not the full unique combination).

‚∏ª

3. Audit Strategy Model
	‚Ä¢	Audit Strategy introduces Audit Assurance and Audit Component.
	‚Ä¢	Each Audit Component maps to a unique combination of
OU + BP + RC + ToR + Control + Control Objective.

‚∏ª

4. Generic Model (EAV) ‚Äì Centralized Unique Combinations
	‚Ä¢	We create entities for Audit Assurance, Audit Component, Data Privacy, and Taxonomy Combination.
	‚Ä¢	Taxonomy Combination holds the full unique set (OU ‚Üí Control Objective).
	‚Ä¢	Relationship Audit Component ‚Üí Taxonomy Combination gives us a single master list.
	‚Ä¢	Each relationship has a unique Relationship ID used by all downstream systems.

‚∏ª

5. How PCAT Uses This Now
	‚Ä¢	During scoping, PCAT stores the taxonomy attributes + the Relationship ID (source = Audit Strategy).
	‚Ä¢	This ID ties the PCAT record back to the central taxonomy + audit strategy definition.

‚∏ª

‚ú® One-Line Summary

All scoping now aligns to a central master via a unique Relationship ID that represents the full taxonomy combination under a given Audit Component.

‚∏ª

If you‚Äôd like, I can also convert this into one slide / one diagram for even faster comprehension.











Below is a clean, structured, MD-friendly summary of your full data-model explanation.
I‚Äôve rewritten it in a way that is conceptually clear, business-oriented, and precise, so you can directly paste it into an email to your MD.

‚∏ª

üìå Subject: Summary of Our Data Model for Taxonomy, Audit Strategy, and PCAT Scoping

Hi ,

Sharing a structured summary of our overall data model spanning taxonomy, PCAT scoping, and the new audit-strategy‚Äìdriven coverage.

‚∏ª

1. PKET / PCAT Model (MongoDB ‚Äì Project-Level View)

We already have a validated NoSQL model that stores project-level scoping information.

What is stored?

For each project, we store a list of PKET objects, where each object contains:
	‚Ä¢	OU (Operating Unit)
	‚Ä¢	PP / BP (Business Process)
	‚Ä¢	RC (Risk Category)
	‚Ä¢	ToR (Test of Risk / TOR)
	‚Ä¢	Control
	‚Ä¢	Status (e.g., in plan, in scoping)

Each object represents a selected taxonomy combination for that project.
This is the same model that is loaded from cache into the UI for PCAT.

Current Limitation

We do not maintain one master table of unique OU‚ÄìBP‚ÄìRC‚ÄìToR‚ÄìControl combinations.
Instead, the unique combination is created and stored per project in Mongo when a user selects it.

‚∏ª

2. Taxonomy Model (Relational / Structured Master Data)

This model defines the hierarchical relationships among taxonomy elements.

Independent Master Tables
	‚Ä¢	OU
	‚Ä¢	BP
	‚Ä¢	RC
	‚Ä¢	ToR
	‚Ä¢	Control

Relationship Tables

We maintain mappings such as:
	‚Ä¢	OU ‚Üí BP
	‚Ä¢	OU ‚Üí RC
	‚Ä¢	RC ‚Üí ToR
	‚Ä¢	ToR ‚Üí Control

This effectively represents a tree:

OU ‚Üí BP ‚Üí RC ‚Üí ToR ‚Üí Control

This is our master taxonomy repository but, as noted, it does not maintain the full unique combination as a single record today.

‚∏ª

3. Audit Strategy Data Model (New Requirement)

Audit Strategy introduces two dimensions:
	‚Ä¢	Dimension 1: Audit Assurance
	‚Ä¢	Dimension 2: Audit Component

Each Audit Component corresponds to a unique taxonomy combination, extended with:
	‚Ä¢	Control Objective

For example:
OU + BP + RC + ToR + Control + Control Objective ‚Üí scoped under a given Audit Component.

‚∏ª

4. Generic Taxonomy Model (Entity‚ÄìAttribute‚ÄìValue Based)

To generalize and centralize all combinations, we use our generic EAV-based taxonomy framework.

New Entity Types Created
	1.	Audit Assurance (entity node)
	2.	Audit Component (entity node)
	3.	Data Privacy (entity node, parent grouping)
	4.	Taxonomy Combination (entity node representing the full unique combination)

Taxonomy Combination Entity Includes
	‚Ä¢	OU
	‚Ä¢	BP
	‚Ä¢	RC
	‚Ä¢	ToR
	‚Ä¢	Control
	‚Ä¢	Control Objective

We then link Audit Component ‚Üí Taxonomy Combination using a relationship.

Result

This produces the authoritative master list of:

Data Privacy ‚Üí Audit Assurance ‚Üí Audit Component ‚Üí OU ‚Üí BP ‚Üí RC ‚Üí ToR ‚Üí Control ‚Üí Objective

Each relationship record has a unique Relationship ID, which becomes the source of truth for downstream systems.

‚∏ª

5. How PCAT Now Uses Audit Strategy Information

During scoping:
	1.	User selects an Audit Strategy and the corresponding Taxonomy Combination.
	2.	PCAT stores:
	‚Ä¢	The existing taxonomy attributes (OU, BP, RC, ToR, Control)
	‚Ä¢	The Relationship ID
	‚Ä¢	With source type = Audit Strategy

Why this matters?

The Relationship ID directly maps to the generic taxonomy model, which knows:
	‚Ä¢	The audit dimension
	‚Ä¢	The audit component
	‚Ä¢	The underlying OU‚ÄìBP‚ÄìRC‚ÄìToR‚ÄìControl‚ÄìObjective combination

This ensures alignment across PCAT, taxonomy, and all downstream systems.

‚∏ª

6. Summary (One-Line Business Message)

We have standardized our taxonomy and audit-strategy data into a centralized relationship model, where every scoped item‚Äîacross PCAT or any other application‚Äîuses the same unique Relationship ID to represent an OU‚ÄìBP‚ÄìRC‚ÄìToR‚ÄìControl‚ÄìObjective combination under a given audit component.

‚∏ª

If you want, I can also create a diagram or one-slide summary to accompany the email.

Would you like that?
